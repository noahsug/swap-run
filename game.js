// Generated by CoffeeScript 1.6.2
(function() {
  var EnemySpawner, EntityFactory, Game, GameInfo, Renderer, atom, keybindings, util,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  EntityFactory = require("../coffee/entity_factory.coffee").EntityFactory;

  EnemySpawner = require("../coffee/enemy_spawner.coffee").EnemySpawner;

  GameInfo = require("../coffee/game_info.coffee").GameInfo;

  Renderer = require("../coffee/renderer.coffee").Renderer;

  atom = require("../spec/mock/atom_mock.coffee").atom;

  keybindings = require("../coffee/keybindings.coffee").keybindings;

  util = require("../coffee/util.coffee").util;

  exports.Game = Game = (function(_super) {
    __extends(Game, _super);

    function Game() {
      Game.__super__.constructor.apply(this, arguments);
      atom.setDesiredSurfaceArea(500000);
      keybindings.configure();
      this.gameInfo_ = new GameInfo;
      this.renderer_ = new Renderer(this.gameInfo_);
      this.init_();
    }

    Game.prototype.init_ = function() {
      this.gameInfo_.reset();
      this.initPlayer_();
      return this.initEnemySpawner_();
    };

    Game.prototype.initPlayer_ = function() {
      var player;

      player = EntityFactory.create("player");
      player.setKnowledge(this.gameInfo_);
      player.setPos({
        x: atom.width / 2,
        y: atom.height / 2
      });
      return this.gameInfo_.setPlayer(player);
    };

    Game.prototype.initEnemySpawner_ = function() {
      var _this = this;

      this.spawner_ = new EnemySpawner();
      return this.spawner_.on('spawn', function(enemy) {
        return _this.addEnemy_(enemy);
      });
    };

    Game.prototype.addEnemy_ = function(enemy) {
      this.gameInfo_.addEnemy(enemy);
      return enemy.setKnowledge(this.gameInfo_);
    };

    Game.prototype.restart_ = function() {
      return this.init_();
    };

    Game.prototype.draw = function() {
      return this.renderer_.draw();
    };

    Game.prototype.resize = function() {
      return this.draw();
    };

    Game.prototype.update = function(dt) {
      this.listenToKeyboardShortcuts_();
      this.renderer_.update(dt);
      switch (this.gameInfo_.getState()) {
        case 'paused':
          return 'do nothing';
        case 'playing':
          return this.updatePlaying_(dt);
        case 'dying':
          return this.updateDying_(dt);
        case 'lost':
          return this.updateEndGame_();
      }
    };

    Game.prototype.listenToKeyboardShortcuts_ = function() {
      if (atom.input.pressed('pause')) {
        if (this.gameInfo_.getState() === 'paused') {
          return this.gameInfo_.setState('playing');
        } else if (this.gameInfo_.getState() === 'playing') {
          return this.gameInfo_.setState('paused');
        }
      }
    };

    Game.prototype.updatePlaying_ = function(dt) {
      this.spawner_.update(dt);
      this.updateEntities_(dt);
      this.checkCollisions_();
      this.removeInactive_();
      return this.checkGameOver_();
    };

    Game.prototype.updateEntities_ = function(dt) {
      var enemy, _i, _len, _ref;

      _ref = this.gameInfo_.getEnemies();
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        enemy = _ref[_i];
        enemy.update(dt);
      }
      return this.gameInfo_.getPlayer().update(dt);
    };

    Game.prototype.checkCollisions_ = function() {
      var entity, _i, _len, _ref, _results;

      _ref = this.gameInfo_.getCollidedEntities();
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        entity = _ref[_i];
        entity.die();
        if (entity.getType() !== 'player') {
          _results.push(this.renderer_.drawEntityDeath(entity));
        } else {
          _results.push(void 0);
        }
      }
      return _results;
    };

    Game.prototype.removeInactive_ = function() {
      var activeEnemies, prevNumEnemies;

      prevNumEnemies = this.gameInfo_.getEnemies().length;
      activeEnemies = this.gameInfo_.getActiveEnemies();
      this.gameInfo_.setEnemies(activeEnemies);
      return this.gameInfo_.addScore(prevNumEnemies - activeEnemies.length);
    };

    Game.prototype.checkGameOver_ = function() {
      if (!this.gameInfo_.getPlayer().isActive()) {
        return this.gameInfo_.setState('dying');
      }
    };

    Game.prototype.updateDying_ = function(dt) {
      this.updateEntities_(dt);
      if (this.renderer_.playerDeathAnimationFinished()) {
        return this.gameInfo_.setState('lost');
      }
    };

    Game.prototype.updateEndGame_ = function() {
      if (atom.input.down('swap')) {
        return this.restart_();
      }
    };

    return Game;

  })(atom.Game);

}).call(this);

/*
//@ sourceMappingURL=game.map
*/
