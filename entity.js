// Generated by CoffeeScript 1.6.2
(function() {
  var Entity, EntityGraphic, Position, atom, util;

  EntityGraphic = require("../coffee/entity_graphic.coffee").EntityGraphic;

  Position = require("../coffee/position.coffee").Position;

  atom = require("../spec/mock/atom_mock.coffee").atom;

  util = require("../coffee/util.coffee").util;

  exports.Entity = Entity = (function() {
    function Entity(type_) {
      this.type_ = type_;
      this.pos_ = {
        x: 0,
        y: 0
      };
      this.radius_ = 10;
      this.setSpeed(200);
      this.active_ = true;
      this.wasMoving_ = false;
      this.currentDirection_ = 'down';
      this.graphic_ = new EntityGraphic;
      this.reactionTime_ = 0;
      this.timeUntilNextReaction_ = 0;
      this.velocityVector_ = {
        x: 0,
        y: 0
      };
    }

    Entity.prototype.getType = function() {
      return this.type_;
    };

    Entity.prototype.setPos = function(pos) {
      this.pos_.x = pos.x;
      return this.pos_.y = pos.y;
    };

    Entity.prototype.getPos = function() {
      return Position.clone(this.pos_);
    };

    Entity.prototype.setRadius = function(radius_) {
      this.radius_ = radius_;
    };

    Entity.prototype.getRadius = function() {
      return this.radius_;
    };

    Entity.prototype.setSpeed = function(speed_) {
      this.speed_ = speed_;
    };

    Entity.prototype.getSpeed = function() {
      return this.speed_;
    };

    Entity.prototype.setReactionTime = function(reactionTime_) {
      this.reactionTime_ = reactionTime_;
      if (this.timeUntilNextReaction_ > this.reactionTime_) {
        return this.timeUntilNextReaction_ = this.reactionTime_;
      }
    };

    Entity.prototype.makeSlowToReact = function() {
      if (this.timeUntilNextReaction_ < this.reactionTime_ / 2) {
        return this.timeUntilNextReaction_ = this.reactionTime_ / 2;
      }
    };

    Entity.prototype.setKnowledge = function(knowledge_) {
      var _ref;

      this.knowledge_ = knowledge_;
      return (_ref = this.moveBehavior_) != null ? _ref.setKnowledge(this.knowledge_) : void 0;
    };

    Entity.prototype.setMoveBehavior = function(moveBehavior_) {
      this.moveBehavior_ = moveBehavior_;
      this.moveBehavior_.setMovingEntity(this);
      return this.moveBehavior_.setKnowledge(this.knowledge_);
    };

    Entity.prototype.getDirection = function() {
      return this.currentDirection_;
    };

    Entity.prototype.isMoving = function() {
      return this.velocityVector_.x !== 0 || this.velocityVector_.y !== 0;
    };

    Entity.prototype.startedMoving = function() {
      return this.isMoving() && !this.wasMoving_;
    };

    Entity.prototype.stoppedMoving = function() {
      return this.wasMoving_ && !this.isMoving();
    };

    Entity.prototype.isActive = function() {
      return this.active_;
    };

    Entity.prototype.die = function() {
      return this.active_ = false;
    };

    Entity.prototype.update = function(dt) {
      if (this.moveBehavior_) {
        this.wasMoving_ = this.isMoving();
        this.move_(dt);
        this.updateDirection_();
      }
      return this.graphic_.update();
    };

    Entity.prototype.setGraphic = function(graphic_) {
      this.graphic_ = graphic_;
      return this.graphic_.setEntity(this);
    };

    Entity.prototype.getGraphic = function() {
      return this.graphic_;
    };

    Entity.prototype.draw = function(context) {
      return this.graphic_.draw(context);
    };

    Entity.prototype.move_ = function(dt) {
      if (!this.isActive()) {
        this.velocityVector_.x = this.velocityVector_.y = 0;
      } else if (this.canChangeMovement_(dt)) {
        this.velocityVector_ = this.moveBehavior_.getVelocityVector();
      }
      return this.updatePosition_(dt);
    };

    Entity.prototype.canChangeMovement_ = function(dt) {
      if (this.reactionTime_ <= dt) {
        return true;
      }
      if (this.timeUntilNextReaction_ < dt) {
        this.timeUntilNextReaction_ = (this.timeUntilNextReaction_ - dt) + this.reactionTime_;
        return true;
      } else {
        this.timeUntilNextReaction_ -= dt;
        return false;
      }
    };

    Entity.prototype.updatePosition_ = function(dt) {
      this.pos_.x += this.velocityVector_.x * this.speed_ * dt;
      return this.pos_.y += this.velocityVector_.y * this.speed_ * dt;
    };

    Entity.prototype.updateDirection_ = function() {
      if (!this.isMoving()) {
        return;
      }
      if (Math.abs(this.velocityVector_.y) > Math.abs(this.velocityVector_.x)) {
        return this.currentDirection_ = this.velocityVector_.y > 0 ? 'down' : 'up';
      } else {
        return this.currentDirection_ = this.velocityVector_.x > 0 ? 'right' : 'left';
      }
    };

    return Entity;

  })();

}).call(this);

/*
//@ sourceMappingURL=entity.map
*/
